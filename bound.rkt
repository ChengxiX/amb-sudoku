#lang racket/base
(define (and-sum list) (if (null? list) #t (and (car list) (and-sum (cdr list)))))
(define (make-number n) (lambda () n))
(define (make-amb possible-choices)
  (define current-choices '())
  (define (restart) (set! current-choices (let ((rec (lambda (rest self) (if (null? rest) rest (cons (car rest) (self (cdr rest) self)))))) (rec possible-choices rec))))
  (define (current) (car current-choices))
  (define update-call '())
  (define (call op) (map (lambda (c) (c op)) update-call))
  (define (renew) (set! current-choices (cdr current-choices))
    (if (null? current-choices) (begin (restart) (set! state 'unset) #f) #t))
  (define (auto-search) (if (renew) (if (and-sum (call 'update)) #t (auto-search)) #f))
  (define state 'unset)
  (restart)
  (define (dispatch . op)
    (cond
      ((null? op) (if (eq? state 'unset) (list 'amb possible-choices) (current)))
      ((eq? (car op) 'start) (if (eq? state 'unset) (begin (set! state 'set) (if (and-sum (call 'update)) 'done (auto-search))) (auto-search))) ; 接上caller
      ((eq? (car op) 'add-update-call) (set! update-call (cons (cadr op) update-call)))
      ;((eq? (car op) 'restart) (set! state 'unset) (restart))
      ;((eq? (car op) 'set-state) (set! state (cadr op)))
      ((eq? (car op) 'get-state) state)
      ))
  dispatch)
(define (unique-check args-list)
  (define (iter rest) (if (null? rest) #t (if (and (not (and (list? ((car args-list))) (eq? (car ((car args-list))) 'amb)))
                                                     (not (and (list? ((car rest))) (eq? (car ((car rest))) 'amb)))
                                                     (= ((car args-list)) ((car rest)))) #f (iter (cdr rest)))))
  (if (null? (cdr args-list)) #t
             (and (iter (cdr args-list)) (unique-check (cdr args-list)))))
(define (make-requirement check args)
  (define (dispatch . op) (cond
                       ((eq? (car op) 'add-arg) (set! args (cons (cadr op) args)))
                       ((eq? (car op) 'check) (check args))
                       ((eq? (car op) 'update) (check args))
                       ))
  dispatch
  )
(define (make-brain)
  (define ambs '())
  (define handled-ambs '())
  (define (reason-an-ambs handle)
    (if (handle 'start) (begin (set! handled-ambs (cons handle handled-ambs)) (reason-all-ambs)) (begin (reason-an-ambs (backspace)) (reason-all-ambs))))
  (define (find-first-unset rest)
      (if (eq? ((car rest) 'get-state) 'unset) (car rest) (if (null? (cdr rest)) 'all-done (find-first-unset (cdr rest)))))
  (define (reason-all-ambs)
    (let ((first (find-first-unset ambs))) (if (eq? first 'all-done) 'done (reason-an-ambs first)))
    )
  (define (backspace) (if (null? handled-ambs) (error "fail") (let ((last-amb (car handled-ambs)))
                                                                   (set! handled-ambs (cdr handled-ambs))
                                                                   last-amb)))
  (define (dispatch . op)
    (cond
      ((eq? (car op) 'add-amb) (set! ambs (cons (cadr op) ambs)))
      ((eq? (car op) 'start) (reason-all-ambs))
      )
    )
  dispatch)

(provide make-number make-amb make-requirement unique-check make-brain)

; test
#| (define a (make-requirement unique-check '()))
   (a 'add-arg (make-number 2))
   (a 'add-arg (make-number 3))
   (define b (make-amb '(5 7)))
   (define c (make-amb '(3 5)))
   (a 'add-arg b)
   (a 'add-arg c)
   (b 'add-update-call a)
   (c 'add-update-call a)
   (define brain (make-brain))
   (brain 'add-amb c)
   (brain 'add-amb b)
(brain 'start) |#
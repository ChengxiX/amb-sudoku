(define (solve-sudoku board)
    (define set (list->vector (map (lambda (a) (list->vector (map (lambda (x) (if (char=? x #\.) 0 (string->number (make-string 1 x))) ) a))) board)))
(define (and-sum list) (if (null? list) #t (and (car list) (and-sum (cdr list)))))
(define (make-number n) (lambda () n))
(define (make-amb possible-choices)
  (define current-choices '())
  (define (restart) (set! current-choices (let ((rec (lambda (rest self) (if (null? rest) rest (cons (car rest) (self (cdr rest) self)))))) (rec possible-choices rec))))
  (define (current) (car current-choices))
  (define update-call '())
  (define (call op) (map (lambda (c) (c op)) update-call))
  (define (renew) (set! current-choices (cdr current-choices))
    (if (null? current-choices) (begin (restart) (set! state 'unset) #f) #t))
  (define (auto-search) (if (renew) (if (and-sum (call 'update)) #t (auto-search)) #f))
  (define state 'unset)
  (restart)
  (define (dispatch . op)
    (cond
      ((null? op) (if (eq? state 'unset) (list 'amb possible-choices) (current)))
      ((eq? (car op) 'start) (if (eq? state 'unset) (begin (set! state 'set) (if (and-sum (call 'update)) 'done (auto-search))) (auto-search))) ; 接上caller
      ((eq? (car op) 'add-update-call) (set! update-call (cons (cadr op) update-call)))
      ;((eq? (car op) 'restart) (set! state 'unset) (restart))
      ;((eq? (car op) 'set-state) (set! state (cadr op)))
      ((eq? (car op) 'get-state) state)
      ))
  dispatch)
(define (unique-check args-list)
  (define (iter rest) (if (null? rest) #t (if (and (not (and (list? ((car args-list))) (eq? (car ((car args-list))) 'amb)))
                                                     (not (and (list? ((car rest))) (eq? (car ((car rest))) 'amb)))
                                                     (= ((car args-list)) ((car rest)))) #f (iter (cdr rest)))))
  (if (null? (cdr args-list)) #t
             (and (iter (cdr args-list)) (unique-check (cdr args-list)))))
(define (make-requirement check args)
  (define (dispatch . op) (cond
                       ((eq? (car op) 'add-arg) (set! args (cons (cadr op) args)))
                       ((eq? (car op) 'check) (check args))
                       ((eq? (car op) 'update) (check args))
                       ))
  dispatch
  )
(define (make-brain)
  (define ambs '())
  (define handled-ambs '())
  (define (reason-an-ambs handle)
    (if (handle 'start) (begin (set! handled-ambs (cons handle handled-ambs)) (reason-all-ambs)) (begin (reason-an-ambs (backspace)) (reason-all-ambs))))
  (define (find-first-unset rest)
      (if (eq? ((car rest) 'get-state) 'unset) (car rest) (if (null? (cdr rest)) 'all-done (find-first-unset (cdr rest)))))
  (define (reason-all-ambs)
    (let ((first (find-first-unset ambs))) (if (eq? first 'all-done) 'done (reason-an-ambs first)))
    )
  (define (backspace) (if (null? handled-ambs) (error "fail") (let ((last-amb (car handled-ambs)))
                                                                   (set! handled-ambs (cdr handled-ambs))
                                                                   last-amb)))
  (define (dispatch . op)
    (cond
      ((eq? (car op) 'add-amb) (set! ambs (cons (cadr op) ambs)))
      ((eq? (car op) 'start) (reason-all-ambs))
      )
    )
  dispatch)
    (define (hor n) (vector-ref set n))
(define (ver n) (vector-map (lambda (v) (vector-ref v n)) set))
(define (square n) (let ((line (remainder n 3)) (row (quotient n 3)))
                     (vector
                      (vector-ref (vector-ref set (+ 0 (* 3 row))) (+ 0 (* 3 line)))
                      (vector-ref (vector-ref set (+ 1 (* 3 row))) (+ 0 (* 3 line)))
                      (vector-ref (vector-ref set (+ 2 (* 3 row))) (+ 0 (* 3 line)))
                      (vector-ref (vector-ref set (+ 0 (* 3 row))) (+ 1 (* 3 line)))
                      (vector-ref (vector-ref set (+ 1 (* 3 row))) (+ 1 (* 3 line)))
                      (vector-ref (vector-ref set (+ 2 (* 3 row))) (+ 1 (* 3 line)))
                      (vector-ref (vector-ref set (+ 0 (* 3 row))) (+ 2 (* 3 line)))
                      (vector-ref (vector-ref set (+ 1 (* 3 row))) (+ 2 (* 3 line)))
                      (vector-ref (vector-ref set (+ 2 (* 3 row))) (+ 2 (* 3 line)))
                      )))
(define (which-square row line) (+ (quotient line 3) (* 3 (quotient row 3))))
(define brain (make-brain))
(define (available nums) (set-subtract (list->seteq (build-list 9 add1))
                                       (list->seteq (map (lambda (a) (if (number? a) a 0)) (vector->list nums)))))

(define (get-avail i j) (set->list (available
                                    (vector-append
                                     (hor i)
                                     (ver j)
                                     (square (which-square i j)))
                                    )))
(for ((i (build-list 9 values))) (for ((j (build-list 9 values))) (if (= 0 (vector-ref (vector-ref set i) j))
                                                                (let ((avail (get-avail i j)))
                                                                  (if (> (length avail) 1)
                                                                      (let
                                                                          ((amb (make-amb avail)))
                                                                        (brain 'add-amb amb)
                                                                        (vector-set! (vector-ref set i) j amb)
                                                                        )
                                                                      ;(begin (display i) (display j) (display (get-avail 1 4))
                                                                      (vector-set! (vector-ref set i) j (if (null? avail) (error (number->string i) (number->string j)) (car avail))))
                                                                  ) void)))
(vector-map (lambda (s)
              (let ((req (make-requirement unique-check '())) (nums (vector->list s)))
                (for-each (lambda (a) (if (number? a) (req 'add-arg (make-number a)) (begin (req 'add-arg a) (a 'add-update-call req)))) nums)
                )) set) ; 别管这里求值打印的void
(for-each (lambda (n)
            (let ((req (make-requirement unique-check '())) (nums (vector->list (ver n))))
                (for-each (lambda (a) (if (number? a) (req 'add-arg (make-number a)) (begin (req 'add-arg a) (a 'add-update-call req)))) nums)
                )) (build-list 9 values))
(for-each (lambda (n)
            (let ((req (make-requirement unique-check '())) (nums (vector->list (square n))))
                (for-each (lambda (a) (if (number? a) (req 'add-arg (make-number a)) (begin (req 'add-arg a) (a 'add-update-call req)))) nums)
                )) (build-list 9 values))
(brain 'start)
    (set! board (vector->list (vector-map (lambda (line) (vector->list (vector-map (lambda (x) (if (number? x) (number->string x) (number->string (x)))) line))) set)))
  )

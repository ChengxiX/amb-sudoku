#lang racket
(require "bound.rkt")
(require csv-reading)
(define inp (open-input-file "set.CSV"))
(define next-row (make-csv-reader inp
                                  '((newline-type . crlf)
                                    )))
(define set (list->vector (map (lambda (a) (list->vector (map string->number (next-row)))) (make-list 9 0))))
(close-input-port inp)
(define (hor n) (vector-ref set n))
(define (ver n) (vector-map (lambda (v) (vector-ref v n)) set))
(define (square n) (let ((line (remainder n 3)) (row (quotient n 3)))
                     (vector
                      (vector-ref (vector-ref set (+ 0 (* 3 row))) (+ 0 (* 3 line)))
                      (vector-ref (vector-ref set (+ 1 (* 3 row))) (+ 0 (* 3 line)))
                      (vector-ref (vector-ref set (+ 2 (* 3 row))) (+ 0 (* 3 line)))
                      (vector-ref (vector-ref set (+ 0 (* 3 row))) (+ 1 (* 3 line)))
                      (vector-ref (vector-ref set (+ 1 (* 3 row))) (+ 1 (* 3 line)))
                      (vector-ref (vector-ref set (+ 2 (* 3 row))) (+ 1 (* 3 line)))
                      (vector-ref (vector-ref set (+ 0 (* 3 row))) (+ 2 (* 3 line)))
                      (vector-ref (vector-ref set (+ 1 (* 3 row))) (+ 2 (* 3 line)))
                      (vector-ref (vector-ref set (+ 2 (* 3 row))) (+ 2 (* 3 line)))
                      )))
(define (which-square row line) (+ (quotient line 3) (* 3 (quotient row 3))))
(define brain (make-brain))
(define (available nums) (set-subtract (list->seteq (build-list 9 add1))
                                       (list->seteq (map (lambda (a) (if (number? a) a 0)) (vector->list nums)))))

(define (get-avail i j) (set->list (available
                                    (vector-append
                                     (hor i)
                                     (ver j)
                                     (square (which-square i j)))
                                    )))
(for ((i (build-list 9 values))) (for ((j (build-list 9 values))) (if (= 0 (vector-ref (vector-ref set i) j))
                                                                (let ((avail (get-avail i j)))
                                                                  (if (> (length avail) 1)
                                                                      (let
                                                                          ((amb (make-amb avail)))
                                                                        (brain 'add-amb amb)
                                                                        (vector-set! (vector-ref set i) j amb)
                                                                        )
                                                                      ;(begin (display i) (display j) (display (get-avail 1 4))
                                                                      (vector-set! (vector-ref set i) j (if (null? avail) (error (number->string i) (number->string j)) (car avail))))
                                                                  ) void)))
(vector-map (lambda (s)
              (let ((req (make-requirement unique-check '())) (nums (vector->list s)))
                (for-each (lambda (a) (if (number? a) (req 'add-arg (make-number a)) (begin (req 'add-arg a) (a 'add-update-call req)))) nums)
                )) set) ; 别管这里求值打印的void
(for-each (lambda (n)
            (let ((req (make-requirement unique-check '())) (nums (vector->list (ver n))))
                (for-each (lambda (a) (if (number? a) (req 'add-arg (make-number a)) (begin (req 'add-arg a) (a 'add-update-call req)))) nums)
                )) (build-list 9 values))
(for-each (lambda (n)
            (let ((req (make-requirement unique-check '())) (nums (vector->list (square n))))
                (for-each (lambda (a) (if (number? a) (req 'add-arg (make-number a)) (begin (req 'add-arg a) (a 'add-update-call req)))) nums)
                )) (build-list 9 values))
(brain 'start)
(vector-map (lambda (line) (vector-map (lambda (item) (if (number? item) item (item))) line)) set)
;(define u ())
;(define set )
;(define ())